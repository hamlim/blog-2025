/// <reference types="bun" />
import topPostPaths from "#/top-posts.json";
import { collectMetadata, getMDXFiles } from "./collect-metadata";

import type { HydratedFrontmatter } from "#/types";

let metadataPath = "./src/metadata.gen.ts";

export async function generateMetadata() {
  let mdxFiles = await getMDXFiles();

  let metadata = await collectMetadata(mdxFiles);

  // metadata.gen.ts:
  // biome-ignore lint/correctness/noUnusedLabels: <explanation>
  // biome-ignore lint/suspicious/noConfusingLabels: <explanation>
  metadataGen: {
    let contents = `/* Autogenerated file */
/* do not edit */

import type { HydratedFrontmatter } from "#/types";
`;
    contents += `
export let metadata: Array<HydratedFrontmatter> = ${JSON.stringify(
      metadata,
      null,
      2,
    )};`;

    await Bun.write(metadataPath, contents);
  }

  // collections/top-posts.gen.ts
  // biome-ignore lint/correctness/noUnusedLabels: <explanation>
  // biome-ignore lint/suspicious/noConfusingLabels: <explanation>
  topPostsGen: {
    let topPosts = topPostPaths
      .map((path) =>
        metadata.find(
          (post) =>
            post.type === "blog-post" &&
            post.path === path &&
            post.status === "public",
        ),
      )
      .filter((post): post is HydratedFrontmatter => post !== undefined);

    await Bun.write(
      "./src/collections/top-posts.gen.ts",
      `/* Autogenerated file */
/* do not edit */
import type { HydratedFrontmatter } from "#/types";

export let topPosts: Array<HydratedFrontmatter> = ${JSON.stringify(
        topPosts,
        null,
        2,
      )}`,
    );
  }

  // collections/recent-posts.gen.ts
  // biome-ignore lint/correctness/noUnusedLabels: <explanation>
  // biome-ignore lint/suspicious/noConfusingLabels: <explanation>
  recentPostsGen: {
    let recentPosts = metadata
      .filter((post) => post.type === "blog-post" && post.status === "public")
      .sort((a, b) => {
        return new Date(b.date).getTime() - new Date(a.date).getTime();
      })
      .slice(0, 5);

    await Bun.write(
      "./src/collections/recent-posts.gen.ts",
      `/* Autogenerated file */
/* do not edit */
import type { HydratedFrontmatter } from "#/types";

export let recentPosts: Array<HydratedFrontmatter> = ${JSON.stringify(
        recentPosts,
        null,
        2,
      )}`,
    );
  }

  // collections/recent-snippets.gen.ts
  // biome-ignore lint/correctness/noUnusedLabels: <explanation>
  // biome-ignore lint/suspicious/noConfusingLabels: <explanation>
  recentSnippetsGen: {
    let recentSnippets = metadata
      .filter(
        (snippet) => snippet.type === "snippet" && snippet.status === "public",
      )
      .sort((a, b) => {
        return new Date(b.date).getTime() - new Date(a.date).getTime();
      })
      .slice(0, 5);

    await Bun.write(
      "./src/collections/recent-snippets.gen.ts",
      `/* Autogenerated file */
/* do not edit */
import type { HydratedFrontmatter } from "#/types";

export let recentSnippets: Array<HydratedFrontmatter> = ${JSON.stringify(
        recentSnippets,
        null,
        2,
      )}`,
    );
  }

  // collections/recent-microposts.gen.ts
  // biome-ignore lint/correctness/noUnusedLabels: <explanation>
  // biome-ignore lint/suspicious/noConfusingLabels: <explanation>
  recentMicropostsGen: {
    let recentMicroposts = metadata
      .filter(
        (update) => update.type === "micropost" && update.status === "public",
      )
      .sort((a, b) => {
        return new Date(b.date).getTime() - new Date(a.date).getTime();
      })
      .slice(0, 5);

    await Bun.write(
      "./src/collections/recent-microposts.gen.ts",
      `/* Autogenerated file */
/* do not edit */
import type { HydratedFrontmatter } from "#/types";

export let recentMicroposts: Array<HydratedFrontmatter> = ${JSON.stringify(
        recentMicroposts,
        null,
        2,
      )}`,
    );
  }
}
